# social auth

oauth请求签名逻辑的通用

https://github.com/oauthlib/oauthlib


https://stackoverflow.com/questions/27051209/how-can-i-use-django-oauth-toolkit-with-python-social-auth

# DOT

CODE认证方式

```sh
curl -X POST \
    -H "Cache-Control: no-cache" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    "http://127.0.0.1:8000/o/token/" \
    -d "client_id=${ID}" \
    -d "client_secret=${SECRET}" \
    -d "code=${CODE}" \
    -d "redirect_uri=http://127.0.0.1:8000/noexist/callback" \
    -d "grant_type=authorization_code"

http://127.0.0.1:8000/o/authorize/?response_type=code&client_id=eynr3FswKDNq3d9JxX8hXLvTPROkR1KE9RHQjJda&redirect_uri=http://localhost:8000/

# The OAuth2 provider will return the follow response:
{
  "access_token": "jooqrnOrNa0BrNWlg68u9sl6SkdFZg",
  "expires_in": 36000,
  "token_type": "Bearer",
  "scope": "read write",
  "refresh_token": "HNvDQjjsnvDySaK0miwG4lttJEl9yD"
}
# To access the user resources we just use the access_token:
curl \
    -H "Authorization: Bearer jooqrnOrNa0BrNWlg68u9sl6SkdFZg" \
    -X GET http://localhost:8000/resource
```
client_id是你这个应用在oAuth2网站注册的应用获得的。
比如腾讯吧，虽然腾讯不一定是密码模式，但是这里举个例子。
如果你是一个A网站，需要获取用户在腾讯的账户信息,那么你需要在腾讯注册你的应用，获取你的client_id。
这样在认证的时候，腾讯的OAuth就可以区分这个用户授权了哪些应用(你的A网站或者别人的B网站)。
A网站和B网站都有各自的client_id，腾讯根据这个id来区分用户给予的授权
当然了，为了防止伪造，还会另外有一个clinet_secret用于确认你使用的client_id确实是你这个网站所持有的。
还有你所不理解的几个参与者。
还是以上面的例子解释。
用户 是腾讯的用户，A网站或者B网站需要用户的授权来获取用户的腾讯账户的信息。
相似问题
第三方客户端 就是A网站或者B网站的手机APP(网页)之类的。
授权服务端 就是指腾讯啦
客户端 就是指A网站或者B网站的服务器
至于为什么要分成第三方客户端和客户端，这个主要是为了secret_id保密，如果你的secret_id直接写在用户应用当中，那么谁都可
以用你的A网站的身份去获取用户的信息了。所以secret_id只能保存在后台。
所以在这里可以理解成客户端就是指A网站的服务器，在面对腾讯的Oauth授权的情况下，腾讯是授权服务端，A网站后台是授权的客
户端。

url 设置

```sh
# 当前url跳转顺序
http://127.0.0.1:8000/auth/login/github

# 但是未直接设置client_id,
https://github.com/login/oauth/authorize?client_id=None&redirect_uri=http://127.0.0.1:8000/auth/complete/github/&state=XmvyShXPpejboI4vQ5bk3kqRdNMCDpMv&response_type=code

# 若是正确设置了client_id
https://github.com/login/oauth/authorize?client_id=e223bbe3748d43cd9220&redirect_uri=http://127.0.0.1:8000/auth/complete/github/&state=XmvyShXPpejboI4vQ5bk3kqRdNMCDpMv&response_type=code

# 会自动跳转到设置好的callback界面, 后面会带有跳转时添加的code和状态值
http://127.0.0.1:8000/auth/complete/github/?code=2adbf2b4ff5198d49f49&state=XmvyShXPpejboI4vQ5bk3kqRdNMCDpMv
```

```sh
http://127.0.0.1:8000/o/token/

# django-rest-framework-social-oauth2
app_name = 'drfso2'

urlpatterns = [
    url(r'^authorize/?$', AuthorizationView.as_view(), name="authorize"),
    url(r'^token/?$', TokenView.as_view(), name="token"),
    url('', include('social_django.urls', namespace="social")),
    url(r'^convert-token/?$', ConvertTokenView.as_view(), name="convert_token"),
    url(r'^revoke-token/?$', RevokeTokenView.as_view(), name="revoke_token"),
    url(r'^invalidate-sessions/?$', invalidate_sessions, name="invalidate_sessions"),
    url(r'^disconnect-backend/?$', DisconnectBackendView.as_view(), name="disconnect_backend")
]

# oauth2_provider urls
app_name = "oauth2_provider"


base_urlpatterns = [
    re_path(r"^authorize/$", views.AuthorizationView.as_view(), name="authorize"),
    re_path(r"^token/$", views.TokenView.as_view(), name="token"),
    re_path(r"^revoke_token/$", views.RevokeTokenView.as_view(), name="revoke-token"),
    re_path(r"^introspect/$", views.IntrospectTokenView.as_view(), name="introspect"),
]


management_urlpatterns = [
    # Application management views
    re_path(r"^applications/$", views.ApplicationList.as_view(), name="list"),
    re_path(r"^applications/register/$", views.ApplicationRegistration.as_view(), name="register"),
    re_path(r"^applications/(?P<pk>[\w-]+)/$", views.ApplicationDetail.as_view(), name="detail"),
    re_path(r"^applications/(?P<pk>[\w-]+)/delete/$", views.ApplicationDelete.as_view(), name="delete"),
    re_path(r"^applications/(?P<pk>[\w-]+)/update/$", views.ApplicationUpdate.as_view(), name="update"),
    # Token management views
    re_path(r"^authorized_tokens/$", views.AuthorizedTokensListView.as_view(), name="authorized-token-list"),
    re_path(
        r"^authorized_tokens/(?P<pk>[\w-]+)/delete/$",
        views.AuthorizedTokenDeleteView.as_view(),
        name="authorized-token-delete",
    ),
]


urlpatterns = base_urlpatterns + management_urlpatterns

# social_django urls
app_name = 'social'

urlpatterns = [
    # authentication / association
    url(r'^login/(?P<backend>[^/]+){0}$'.format(extra), views.auth,
        name='begin'),
    url(r'^complete/(?P<backend>[^/]+){0}$'.format(extra), views.complete,
        name='complete'),
    # disconnection
    url(r'^disconnect/(?P<backend>[^/]+){0}$'.format(extra), views.disconnect,
        name='disconnect'),
    url(r'^disconnect/(?P<backend>[^/]+)/(?P<association_id>\d+){0}$'
        .format(extra), views.disconnect, name='disconnect_individual'),
]

```

通过管道获取更多信息
```md
您可以在社交身份验证管道上添加（或删除）多个功能。

默认情况下，social_django上有一些管道：

social_details-获取我们可以获取的有关用户的信息，并以简单的格式返回它，以便稍后创建用户实例。在某些情况下，详细信息已经成为提供程序的auth响应的一部分，但是有时这可能会影响提供程序的API。

social_uid-从我们正通过的任何服务中获取社交uid。uid是提供者中给定用户的唯一标识符。

auth_allowed -验证当前身份验证过程在当前项目中是否有效，这是应用电子邮件和域白名单的位置（如果已定义）。

social_user -检查当前的社交帐户是否已在网站中关联。

get_username-为这个人准备一个用户名，如果有冲突，在结尾处添加一个随机字符串。

create_user -如果尚未找到一个用户帐户，请创建一个。

associate_user -创建将社交帐户与此用户相关联的记录。

extra_data -使用设置（以及默认值，例如access_token等）指定的值填充社交记录中的extra_data字段。

user_details -使用来自auth服务的任何更改的信息来更新用户记录。

其他一些管道也可以使用，但默认情况下不包括在内：

associate_by_email-将当前身份验证与数据库中具有相同电子邮件地址的用户相关联。观察：该管道输入不是100％安全的，除非您知道提供商启用了他们旁边的强制电子邮件验证，否则用户可以尝试通过使用某些提供商上的相同（未验证）电子邮件地址来接管另一个用户帐户。

用法示例：

SOCIAL_AUTH_PIPELINE = (
    'social_core.pipeline.social_auth.social_details',
    'social_core.pipeline.social_auth.social_uid',
    'social_core.pipeline.social_auth.social_user',
    'social_core.pipeline.user.get_username',
    'social_core.pipeline.social_auth.associate_by_email',
    'social_core.pipeline.user.create_user',
    'social_core.pipeline.social_auth.associate_user',
    'social_core.pipeline.social_auth.load_extra_data',
    'social_core.pipeline.user.user_details',
)
# 使用pipline 获取三方登录的信息
https://www.shuzhiduo.com/A/amd0jVA6Jg/

https://python-social-auth.readthedocs.io/en/latest/developer_intro.html?highlight=pipeline#understanding-the-pipeline

https://python-social-auth.readthedocs.io/en/latest/pipeline.html

获取用户信息
https://medium.com/@me_12358/fetching-the-google-profile-picture-while-using-django-social-auth-34bc49c8d39d

https://blog.itswcg.com/2018/12/django-middleware-and-pipeline/

https://docs.raven.cam.ac.uk/en/latest/django-oauth2/

https://tryolabs.com/blog/2012/02/13/get-user-data-using-django-social-auth/
```

```sh
# 获取token和refresh token 获取认证信息
curl -X POST -H "Authorization: Basic ${CREDENTIAL}" -H "Cache-Control: no-cache" -H "Content-Type: application/x-www-form-urlencoded" "http://127.0.0.1:8000/o/token/" -d "grant_type=client_credentials"

# 刷新token
curl -X POST -d "grant_type=refresh_token&client_id=<your_client_id>&client_secret=<your_client_secret>&refresh_token=<your_refresh_token>" http://localhost:8000/o/token/



# 通过
# https://stackoverflow.com/questions/26903087/how-to-use-refresh-token-for-getting-new-access-tokendjango-oauth-toolkit
# https://django-oauth-toolkit.readthedocs.io/en/0.5.0/tutorial/tutorial_02.html
# https://www.reviewboard.org/docs/djblets/1.0/guides/webapi/adding-oauth2-support/
from oauth2_provider.views.generic import ProtectedResourceView

class ApiEndpoint(ProtectedResourceView):
    def get(self, request, *args, **kwargs):
        return HttpResponse('Hello, OAuth2!')

```


https://stackoverflow.com/questions/26903087/how-to-use-refresh-token-for-getting-new-access-tokendjango-oauth-toolkit

https://github.com/jazzband/django-oauth-toolkit/blob/master/docs/getting_started.rst


https://segmentfault.com/q/1010000016293133/a-1020000016293417

https://github.com/jazzband/django-oauth-toolkit

https://django-oauth-toolkit.readthedocs.io/en/latest/

https://blog.csdn.net/GiveMeFive_Y/article/details/79291384

https://github.com/jazzband/django-oauth-toolkit/blob/master/docs/getting_started.rst

https://github.com/jazzband/django-oauth-toolkit/blob/master/docs/templates.rst

https://my.oschina.net/mesopotamia/blog/761605

https://www.liip.ch/en/blog/authorization-code-with-pkce-on-django-using-django-oauth-toolkit

github登录

https://docs.github.com/en/free-pro-team@latest/developers/apps/authorizing-oauth-apps

https://docs.github.com/cn

https://docs.github.com/cn/free-pro-team@latest/developers/apps/identifying-and-authorizing-users-for-github-apps

scope github登录的
https://docs.github.com/en/free-pro-team@latest/developers/apps/scopes-for-oauth-apps

微博登录

https://open.weibo.com/wiki/%E6%8E%88%E6%9D%83%E6%9C%BA%E5%88%B6%E8%AF%B4%E6%98%8E

https://github.com/python-social-auth/social-app-django

https://github.com/python-social-auth/social-core

https://www.codenong.com/27051209/

https://realpython.com/adding-social-authentication-to-django/

https://www.cnblogs.com/iread9527/p/13138179.html


https://www.cnblogs.com/shijieli/p/10787203.html

https://my.oschina.net/duoduo3369/blog/300858

https://segmentfault.com/a/1190000008701211



# django 开发常用软件包

https://www.liujiangblog.com/blog/35/

https://github.com/justquick/django-activity-stream




# 登录认证库

JAVA
https://github.com/justauth/JustAuth

PYTHON
https://github.com/jazzband/django-oauth-toolkit

https://github.com/pennersr/django-allauth

LARAVEL
https://learnku.com/laravel/t/1202/laravel51-achieve-third-party-login-authentication-including-micro-blog-qq-wechat-watercress

# 例子参考

https://github.com/felix-d/Django-Oauth-Toolkit-Python-Social-Auth-Integration

https://github.com/evonove/django-oauth-toolkit-example

https://github.com/Humanitec/django-oauth-toolkit-jwt/blob/master/oauth2_provider_jwt/views.py


django-oauth-toolkit 创建用户最佳实践




# Ansible Tower

http://ansible.com.cn/docs/tower.html

https://docs.ansible.com/ansible-tower/3.8.0/html_zh/administration//oauth2_token_auth.html

https://github.com/ansible

https://python.libhunt.com/django-oauth-toolkit-alternatives


活动流注册:
activity_stream_registrar

https://github.com/ansible/awx/blob/abc6a842105999bfaadf312ed1fb9596574355bf/awx/main/models/__init__.py



> awx定义的rest framework generics

```python
from awx.api.generics import (
    APIView, BaseUsersList, CopyAPIView, DeleteLastUnattachLabelMixin,
    GenericAPIView, ListAPIView, ListCreateAPIView,
    ResourceAccessList, RetrieveAPIView, RetrieveDestroyAPIView,
    RetrieveUpdateAPIView, RetrieveUpdateDestroyAPIView, SimpleListAPIView,
    SubDetailAPIView, SubListAPIView, SubListAttachDetachAPIView,
    SubListCreateAPIView, SubListCreateAttachDetachAPIView,
    SubListDestroyAPIView
)
```

user serializer
https://github.com/ansible/awx/blob/29926ba5d99b760b32de35e07c211fd3e7691c8d/awx/api/serializers.py

> awx 的swagger 逻辑

https://github.com/ansible/awx/blob/29926ba5d9/awx/api/swagger.py

> awx 的rest 分页插件

https://github.com/ansible/awx/blob/29926ba5d9/awx/api/pagination.py

> awx 的认证逻辑

https://github.com/ansible/awx/blob/29926ba5d9/awx/api/authentication.py

>JWT 认证逻辑

https://github.com/mozilla/addons-server/blob/master/src/olympia/api/jwt_auth.py


```python
# urls 覆盖了原有django_oauth2_tool的url 重写了部分认证的逻辑
# https://github.com/ansible/awx/blob/29926ba5d9/awx/api/urls/oauth2.py
# https://github.com/ansible/awx/blob/29926ba5d9/awx/api/urls/oauth2_root.py
urls = [
    url(r'^$', ApiOAuthAuthorizationRootView.as_view(), name='oauth_authorization_root_view'),
    url(r"^authorize/$", views.AuthorizationView.as_view(), name="authorize"),
    url(r"^token/$", TokenView.as_view(), name="token"),
    url(r"^revoke_token/$", views.RevokeTokenView.as_view(), name="revoke-token"),
]


from oauth2_provider.models import Grant, RefreshToken
# awx修正适配过的model 
# https://github.com/ansible/awx/blob/29926ba5d9/awx/main/models/oauth.py
from awx.main.models.oauth import ( # noqa
    OAuth2AccessToken, OAuth2Application
)


# prevent API filtering on certain Django-supplied sensitive fields
prevent_search(User._meta.get_field('password'))
prevent_search(OAuth2AccessToken._meta.get_field('token'))
prevent_search(RefreshToken._meta.get_field('token'))
prevent_search(OAuth2Application._meta.get_field('client_secret'))
prevent_search(OAuth2Application._meta.get_field('client_id'))
prevent_search(Grant._meta.get_field('code'))

# https://github.com/ansible/awx/blob/29926ba5d9/awx/main/models/__init__.py

class BaseOAuth2TokenSerializer(BaseSerializer):

    refresh_token = serializers.SerializerMethodField()
    token = serializers.SerializerMethodField()
    ALLOWED_SCOPES = ['read', 'write']

    class Meta:
        model = OAuth2AccessToken
        fields = (
            '*', '-name', 'description', 'user', 'token', 'refresh_token',
            'application', 'expires', 'scope',
        )
        read_only_fields = ('user', 'token', 'expires', 'refresh_token')
        extra_kwargs = {
            'scope': {'allow_null': False, 'required': False},
            'user': {'allow_null': False, 'required': True}
        }

    def get_token(self, obj):
        request = self.context.get('request', None)
        try:
            if request.method == 'POST':
                return obj.token
            else:
                return CENSOR_VALUE
        except ObjectDoesNotExist:
            return ''

    def get_refresh_token(self, obj):
        request = self.context.get('request', None)
        try:
            if not obj.refresh_token:
                return None
            elif request.method == 'POST':
                return getattr(obj.refresh_token, 'token', '')
            else:
                return CENSOR_VALUE
        except ObjectDoesNotExist:
            return None

    def get_related(self, obj):
        ret = super(BaseOAuth2TokenSerializer, self).get_related(obj)
        if obj.user:
            ret['user'] = self.reverse('api:user_detail', kwargs={'pk': obj.user.pk})
        if obj.application:
            ret['application'] = self.reverse(
                'api:o_auth2_application_detail', kwargs={'pk': obj.application.pk}
            )
        ret['activity_stream'] = self.reverse(
            'api:o_auth2_token_activity_stream_list', kwargs={'pk': obj.pk}
        )
        return ret

    def _is_valid_scope(self, value):
        if not value or (not isinstance(value, str)):
            return False
        words = value.split()
        for word in words:
            if words.count(word) > 1:
                return False  # do not allow duplicates
            if word not in self.ALLOWED_SCOPES:
                return False
        return True

    def validate_scope(self, value):
        if not self._is_valid_scope(value):
            raise serializers.ValidationError(_(
                'Must be a simple space-separated string with allowed scopes {}.'
            ).format(self.ALLOWED_SCOPES))
        return value

    def create(self, validated_data):
        validated_data['user'] = self.context['request'].user
        try:
            return super(BaseOAuth2TokenSerializer, self).create(validated_data)
        except oauth2.AccessDeniedError as e:
            raise PermissionDenied(str(e))

class UserAuthorizedTokenSerializer(BaseOAuth2TokenSerializer):

    class Meta:
        extra_kwargs = {
            'scope': {'allow_null': False, 'required': False},
            'user': {'allow_null': False, 'required': True},
            'application': {'allow_null': False, 'required': True}
        }

    def create(self, validated_data):
        current_user = self.context['request'].user
        validated_data['token'] = generate_token()
        validated_data['expires'] = now() + timedelta(
            seconds=settings.OAUTH2_PROVIDER['ACCESS_TOKEN_EXPIRE_SECONDS']
        )
        obj = super(UserAuthorizedTokenSerializer, self).create(validated_data)
        obj.save()
        if obj.application:
            RefreshToken.objects.create(
                user=current_user,
                token=generate_token(),
                application=obj.application,
                access_token=obj
            )
        return obj

class OAuth2TokenSerializer(BaseOAuth2TokenSerializer)
# https://github.com/ansible/awx/blob/29926ba5d99b760b32de35e07c211fd3e7691c8d/awx/api/serializers.py

class UserAuthorizedTokenList(SubListCreateAPIView):

    name = _("OAuth2 User Authorized Access Tokens")

    model = models.OAuth2AccessToken
    serializer_class = serializers.UserAuthorizedTokenSerializer
    parent_model = models.User
    relationship = 'oauth2accesstoken_set'
    parent_key = 'user'
    swagger_topic = 'Authentication'

    def get_queryset(self):
        return get_access_token_model().objects.filter(application__isnull=False, user=self.request.user)
# https://github.com/ansible/awx/blob/29926ba5d99b760b32de35e07c211fd3e7691c8d/awx/api/views/__init__.py

```
https://github.com/ansible/awx/blob/d93d0f00ee37e0dbda8d11561c5068c6b8f88a67/awx/main/access.py