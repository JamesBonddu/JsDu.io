# 漏洞错误类型

CNNVD将信息安全漏洞划分为26种类型，分别是：配置错误、代码问题、资源管理错误、数字错误、信息泄露、竞争条件、输入验证、缓冲区错误、格式化字符串、跨站脚本、路径遍历、后置链接、SQL注入、注入、代码注入、命令注入、操作系统命令注入、安全特征问题、授权问题、信任管理、加密问题、未充分验证数据可靠性、跨站请求伪造、权限许可和访问控制、访问控制错误、资料不足。


http://www.cnnvd.org.cn/web/wz/bzxqById.tag?id=3&mkid=3

https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html

# web.config漏洞

```sh
total 40
drwxr-xr-x  6 root root 4096 Mar 25  2021 ./
drwxr-xr-x 13 root root 4096 May 13  2021 ../
drwxr-xr-x  2 root root 4096 Dec 24  2020 css/
-rw-r--r--  1 root root    0 Nov  9  2020 favicon.ico
-rw-r--r--  1 root root  603 Nov  9  2020 .htaccess
-rw-r--r--  1 root root 1731 Nov  9  2020 index.php
drwxr-xr-x  2 root root 4096 Nov  4 13:52 js/
-rw-r--r--  1 root root   24 Nov  9  2020 robots.txt
drwxr-xr-x  6 root root 4096 Apr  9  2021 uploads/
drwxr-xr-x  5 root root 4096 Nov 20  2020 vendor/
-rw-r--r--  1 root root 1194 Nov  9  2020 web.config


cat /opt/xxx/public/.htaccess 
<IfModule mod_rewrite.c>
    <IfModule mod_negotiation.c>
        Options -MultiViews -Indexes
    </IfModule>

    RewriteEngine On

    # Handle Authorization Header
    RewriteCond %{HTTP:Authorization} .
    RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]

    # Redirect Trailing Slashes If Not A Folder...
    RewriteCond %{REQUEST_FILENAME} !-d
    RewriteCond %{REQUEST_URI} (.+)/$
    RewriteRule ^ %1 [L,R=301]

    # Send Requests To Front Controller...
    RewriteCond %{REQUEST_FILENAME} !-d
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteRule ^ index.php [L]
</IfModule>

cat /opt/xxx/public/web.config 
<!--
    Rewrites requires Microsoft URL Rewrite Module for IIS
    Download: https://www.microsoft.com/en-us/download/details.aspx?id=47337
    Debug Help: https://docs.microsoft.com/en-us/iis/extensions/url-rewrite-module/using-failed-request-tracing-to-trace-rewrite-rules
-->
<configuration>
  <system.webServer>
    <rewrite>
      <rules>
        <rule name="Imported Rule 1" stopProcessing="true">
          <match url="^(.*)/$" ignoreCase="false" />
          <conditions>
            <add input="{REQUEST_FILENAME}" matchType="IsDirectory" ignoreCase="false" negate="true" />
          </conditions>
          <action type="Redirect" redirectType="Permanent" url="/{R:1}" />
        </rule>
        <rule name="Imported Rule 2" stopProcessing="true">
          <match url="^" ignoreCase="false" />
          <conditions>
            <add input="{REQUEST_FILENAME}" matchType="IsDirectory" ignoreCase="false" negate="true" />
            <add input="{REQUEST_FILENAME}" matchType="IsFile" ignoreCase="false" negate="true" />
          </conditions>
          <action type="Rewrite" url="index.php" />
        </rule>
      </rules>
    </rewrite>
  </system.webServer>
</configuration>
```

nginx 层做下控制

```sh
location ~* \.(config|ini|docx|txt|doc)$ {
          # deny all;
                return 404;
}
```

https://www.freebuf.com/articles/web/173831.html

https://www.4hou.com/posts/LAlp

https://learnku.com/laravel/t/50498

https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/iis/web-config?view=aspnetcore-6.0


## web.config上传技术研究

一种运行ASP的经典代码方法，即通过上传web.config文件来执行存储型XSS攻击。

https://xz.aliyun.com/t/6037

https://www.stackhawk.com/blog/laravel-xss/


# TLS1.0 TLS1.1 漏洞修复

```sh
nmap --script ssl-enum-ciphers -p 443 host

Starting Nmap 7.60 ( https://nmap.org ) at 2021-11-29 09:38 CST
Nmap scan report for xxx
Host is up (0.00043s latency).

PORT    STATE SERVICE
443/tcp open  https
| ssl-enum-ciphers: 
|   TLSv1.0: 
|     ciphers: 
|       TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA (rsa 2048) - A
|       TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA (rsa 2048) - A
|       TLS_RSA_WITH_AES_256_CBC_SHA (rsa 2048) - A
|       TLS_RSA_WITH_CAMELLIA_256_CBC_SHA (rsa 2048) - A
|       TLS_RSA_WITH_AES_128_CBC_SHA (rsa 2048) - A
|       TLS_RSA_WITH_CAMELLIA_128_CBC_SHA (rsa 2048) - A
|     compressors: 
|       NULL
|     cipher preference: server
|   TLSv1.1: 
|     ciphers: 
|       TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA (rsa 2048) - A
|       TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA (rsa 2048) - A
|       TLS_RSA_WITH_AES_256_CBC_SHA (rsa 2048) - A
|       TLS_RSA_WITH_CAMELLIA_256_CBC_SHA (rsa 2048) - A
|       TLS_RSA_WITH_AES_128_CBC_SHA (rsa 2048) - A
|       TLS_RSA_WITH_CAMELLIA_128_CBC_SHA (rsa 2048) - A
|     compressors: 
|       NULL
|     cipher preference: server
|   TLSv1.2: 
|     ciphers: 
|       TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (rsa 2048) - A
|       TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 (rsa 2048) - A
|       TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 (rsa 2048) - A
|       TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (rsa 2048) - A
|       TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 (rsa 2048) - A
|       TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 (rsa 2048) - A
|       TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 (rsa 2048) - A
|       TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 (rsa 2048) - A
|       TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 (rsa 2048) - A
|       TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA (rsa 2048) - A
|       TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA (rsa 2048) - A
|       TLS_RSA_WITH_AES_256_GCM_SHA384 (rsa 2048) - A
|       TLS_RSA_WITH_AES_256_CCM_8 (rsa 2048) - A
|       TLS_RSA_WITH_AES_256_CCM (rsa 2048) - A
|       TLS_RSA_WITH_ARIA_256_GCM_SHA384 (rsa 2048) - A
|       TLS_RSA_WITH_AES_128_GCM_SHA256 (rsa 2048) - A
|       TLS_RSA_WITH_AES_128_CCM_8 (rsa 2048) - A
|       TLS_RSA_WITH_AES_128_CCM (rsa 2048) - A
|       TLS_RSA_WITH_ARIA_128_GCM_SHA256 (rsa 2048) - A
|       TLS_RSA_WITH_AES_256_CBC_SHA256 (rsa 2048) - A
|       TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 (rsa 2048) - A
|       TLS_RSA_WITH_AES_128_CBC_SHA256 (rsa 2048) - A
|       TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 (rsa 2048) - A
|       TLS_RSA_WITH_AES_256_CBC_SHA (rsa 2048) - A
|       TLS_RSA_WITH_CAMELLIA_256_CBC_SHA (rsa 2048) - A
|       TLS_RSA_WITH_AES_128_CBC_SHA (rsa 2048) - A
|       TLS_RSA_WITH_CAMELLIA_128_CBC_SHA (rsa 2048) - A
|     compressors: 
|       NULL
|     cipher preference: server
|_  least strength: A

Nmap done: 1 IP address (1 host up) scanned in 1.03 seconds
```


https://blog.csdn.net/qq_36292543/article/details/119672523

https://blog.csdn.net/qq_39517116/article/details/107504377

https://qingsay.com/nginx-disables-tls.html


# Application error message

异常信息泄露(应用程序错误)

django 处理暴露敏感信息错误

https://blog.csdn.net/weixin_39934520/article/details/107381920


https://cloud.tencent.com/developer/article/1368971

https://www.leavesongs.com/PENETRATION/django-debug-page-xss.html


# Cross-site Scripting XSS攻击

Cross-site Scripting (XSS) refers to client-side code injection attack wherein an attacker can execute malicious scripts into a legitimate website or web application. XSS occurs when a web application makes use of unvalidated or unencoded user input within the output it generates.

laravel 防止XSS攻击

```sh
composer require mews/purifier

# config/app.php的providers中注册HTMLPurifier服务提供者：
'providers' => [
    Mews\Purifier\PurifierServiceProvider::class,
]

# aliases中注册Purifier门面：

'aliases' => [
  // ...
  'Purifier' => Mews\Purifier\Facades\Purifier::class,
]

# 配置文件到config目录:
php artisan vendor:publish


#这个配置文件里注意下，'AutoFormat.AutoParagraph' => true, 选项改为false，不然会在过滤字段中增加<p></p>字符. 之后在需要做防xss攻击的地方直接调用它即可,比如：

$form->saving(function (Form $form){
    $form->title = \Purifier::clean($form->title);
    $form->uri = \Purifier::clean($form->uri );
});


In order to prevent XSS attacks, the default output content will be HTML escape, if you don't want to escape the output HTML, you can call the unescape method:

$show->avatar()->unescape()->as(function ($avatar) {

     return "<img src='{$avatar}' />";

});

```
避免xss攻击


https://learnku.com/articles/32529

https://learnku.com/articles/20710

https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html

https://www.xiaoxiaoguo.cn/php/laravel-admin-03.html

https://laravel-admin.org/docs/en/model-show

https://laravelacademy.org/post/9476

http://htmlpurifier.org/

https://learnku.com/articles/22588

# sql 注入

当你使用 Eloquent 查询时，如：

User::where('name', $input_name)->first();
Eloquent 内部使用的是 PDO 参数绑定，所以你的请求是安全的。虽然如此，在一些允许你使用原生 SQL 语句的地方，还是要特别小心，例如 whereRaw 或者 selectRaw 。如下：

User::whereRaw("name = '$input_name'")->first();
类似于 PDO 参数绑定进行传参，以避免 SQL 注入的风险:

User::whereRaw("name = ?", [$input_name])->first();

https://learnku.com/laravel/wikis/16046

https://laravelacademy.org/post/9476

# 关闭laravel admin debug模式
```sh
APP_NAME=Laravel
APP_ENV=local
APP_KEY=
APP_DEBUG=false
APP_URL=http://localhost

LOG_CHANNEL=single
```

https://dev.to/sureshramani/how-to-enable-and-disable-debug-mode-in-laravel-1d5d

https://github.com/z-song/laravel-admin/issues/3590


# laravel telescope 关闭

http://xxx:8000/telescope/requests

```sh
php artisan telescope:prune
php artisan telescope:clear


```

https://learnku.com/docs/laravel/5.8/telescope/3948

https://stackoverflow.com/questions/54335503/how-can-i-clean-laravel-telescope-debug-log

https://www.oulub.com/Laravel/telescope-installation

# URL 重定向攻击
严格控制将要跳转的域名，如果某个业务事先已经确定将要跳转的网站，最稳妥的方式是将其直接编码在源代码中，通过URL中传入的参数来映射跳转网址。

严格验证跳转URL参数的有效性、合法性。

校验传入的URL参数是否为可信域名

很多软件，比如知乎，简书，如果跳转的是外部链接，会提示用户注意个人隐私安全。

这其实是一个不错的处理方式。

https://cloud.tencent.com/developer/article/1728654

https://houbb.github.io/2020/08/09/web-safe-06-redirect

https://xz.aliyun.com/t/5189

# .htaccess文件攻击

在apache里，这个文件作为一个配置文件，可以用来控制所在目录的访问权限以及解析设置。即是，可以通过设置可以将该目录下的所有文件作为php文件来解析，即可绕过

方式
利用某些写文件函数复写.htaccess文件，即可任意定义解析名单
通过一个.htaccess 文件调用 php 的解析器去解析一个文件名中只要包含”haha”这个字符串的
任意文件，所以无论文件名是什么样子，只要包含”haha”这个字符串，都可以被以 php 的方
式来解析，是不是相当邪恶，一个自定义的.htaccess 文件就可以以各种各样的方式去绕过很
多上传验证机制
建立一个.htaccess文件内容如下

<FilesMatch "haha">
SetHandler application/x-httpd-php
</FilesMatch>

nginx 防护
```sh
location ~ ^.*\.(htaccess|htpasswd|ini|php|sh)$ {
　　deny all;
}

location ~ ^.*\.(htaccess|htpasswd|ini|php|sh|config)$ {
    deny all;
    access_log off;
    log_not_found off;
}

location ~ /\.(?!well-known).* {
    deny all;
    access_log off;
    log_not_found off;
}
```


https://xz.aliyun.com/t/8631

https://blog.51cto.com/u_15274949/2922449

https://serverfault.com/questions/755662/nginx-disable-htaccess-and-hidden-files-but-allow-well-known-directory


# jquery 自带的xss漏洞

https://cloud.tencent.com/developer/article/1638163

https://www.cnblogs.com/nul1/p/12934703.html

#  Clickjacking


点击劫持（Click Jacking）是一种视觉上的欺骗手段，攻击者通过使用一个透明的iframe，覆盖在一个网页上，然后诱使用户在该页面上进行操作，通过调整iframe页面的位置，可以使得伪造的页面恰好和iframe里受害页面里一些功能重合（按钮），以达到窃取用户信息或者劫持用户操作的目的。

Clickjacking是仅此于XSS和CSRF的前端漏洞，因为需要诱使用户交互，攻击成本高，所以不被重视，但危害不容小觑，攻击效果见案例。

对于漏洞的防范大部分浏览器支持的防御办法是使用X-Frame-Options头，通常设置为DENY可以很好地防范漏洞，其次SAMEORIGIN可以在某个页面失守时被绕过，ALLOW-FROM uri不被Chrome支持。其次还有CSP头：Content-Security-Policy: frame-ancestors 'self'仅支持FireFox。

也就是说，如果发现系统没有设置上述头，大概率存在ClickJacking漏洞，测试方法很简单，本地构造一个HTML文件，使用iframe包含此页面：

 主要有三种防御办法：

1）X-Frame-Options，建议设置为DENY；

2）Content-Security-Policy:frame-ancestors 'self'或‘none’，不适用于Safari和IE；

3）js层面：使用iframe的sandbox属性，判断当前页面是否被其他页面嵌套。

  当前最推荐的方案是1和3结合防御，深入了解可以阅读原文，下载斯坦福大学对此漏洞的研究论文。


```sh
# nginx配置：

add_header X-Frame-Options SAMEORIGIN;
X-Frame-Options有三种可能的指示：

X-Frame-Options: DENY
X-Frame-Options: SAMEORIGIN
X-Frame-Options: ALLOW-FROM https://example.com/
```

https://owasp.org/www-community/attacks/Clickjacking

https://cloud.tencent.com/developer/article/1516375

https://blog.csdn.net/lady_killer9/article/details/108017437

https://cloud.tencent.com/developer/section/1190032